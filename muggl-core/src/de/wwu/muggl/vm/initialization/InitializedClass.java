package de.wwu.muggl.vm.initialization;

import java.util.HashMap;

import de.wwu.muggl.configuration.JavaEEConstants;
import de.wwu.muggl.configuration.Options;
import de.wwu.muggl.instructions.MethodResolutionError;
import de.wwu.muggl.javaee.jpa.MugglEntityManager;
import de.wwu.muggl.vm.VirtualMachine;
import de.wwu.muggl.vm.classfile.ClassFile;
import de.wwu.muggl.vm.classfile.ClassFileException;
import de.wwu.muggl.vm.classfile.structures.Attribute;
import de.wwu.muggl.vm.classfile.structures.Constant;
import de.wwu.muggl.vm.classfile.structures.Field;
import de.wwu.muggl.vm.classfile.structures.Method;
import de.wwu.muggl.vm.classfile.structures.attributes.AttributeConstantValue;
import de.wwu.muggl.vm.classfile.structures.attributes.AttributeRuntimeVisibleAnnotations;
import de.wwu.muggl.vm.classfile.structures.attributes.elements.Annotation;

/**
 * This class represents a statically initialized ClassFile. It is used to offer access to the
 * static fields of the classes currently loaded by the virtual machine. It also can supply
 * instances of Objectref, which represent reference values which can be used for full
 * instantiation of ClassFiles.<br />
 * <br />
 * Using the public constructor will lead to the static initialization of the class. This
 * especially includes invocation of the <clinit>-Method, if there is any. Concrete instances
 * can then be derived by using getANewInstance(). An instance generated by getANewInstance()
 * is the representation of an object in this virtual machine implementation.<br />
 * <br />
 * An analogy for clarification:<br />
 * <table>
 * <tr><th>Suns JVM</th><th>Muggl</th></tr>
 * <tr><td>*.class-file</td><td>ClassFile: Offering the representation of the class' structures</td></tr>
 * <tr><td>Class</td><td>InitializedClass: Offering an statically initialized class.</td></tr>
 * <tr><td>Object</td><td>Objectref: Offering an instantiated class, as well as reference to its static fields.</td></tr>
 * </table>
 *
 * @author Tim Majchrzak
 * @version 1.0.0, 2010-03-10
 */
public class InitializedClass extends FieldContainer {
	// The only field - the represented ClassFile.
	private ClassFile representedClassFile;

	public InitializedClass(ClassFile representedClassFile, VirtualMachine vm) {
		this(representedClassFile, vm, false);
	}
	/**
	 * Generate a statically initialized class. This leads to the execution of the <clinit>-Method
	 * (if there is any) to initialize static fields.
	 * @jvms ยง 5.5
	 * @param representedClassFile The ClassFile represented.
	 * @param vm The currently running virtual machine.
	 * @throws ExceptionInInitializerError If class initialization failed.
	 */
	public InitializedClass(ClassFile representedClassFile, VirtualMachine vm, boolean forceFrameIfCurrentNull) {
		// Invoke the super constructor.
		super();
				
		// Set the represented ClassFile.
		this.representedClassFile = representedClassFile;
		
		// do this early, in case anyone in the static initializer calls itself
		// e.g. java.lang.invoke.Invokers -.-
		this.representedClassFile.setupMirrorClass();

		// If there is a super class, it has to be initialized first.
		if (this.representedClassFile.getSuperClass() != 0) {
			ClassFile superClassFile;
			try {
				superClassFile = this.representedClassFile.getClassLoader().getClassAsClassFile(this.representedClassFile.getConstantPool()[this.representedClassFile.getSuperClass()].getStringValue());
			} catch (ClassFileException e) {
				throw new ExceptionInInitializerError("Class initialization failed with a ClassFileException with the message: " + e.getMessage() + ".");
			}
			superClassFile.getTheInitializedClass(vm);
		}

		// Before invoking the static initializer, set the field for this instance in ClassFile.
		this.representedClassFile.putInitializedClass(this);

		// initialize final static fields as per step 6. To be able to read static fields via reflection
		
		for (Field field : this.representedClassFile.getFields()) {
			if (field.isAccStatic() && field.isAccFinal()) {
				for (Attribute attr : field.getAttributes()) {
					if (attr instanceof AttributeConstantValue) {
						AttributeConstantValue constA = (AttributeConstantValue) attr;
						Constant val = constA.getClassFile().getConstantPool()[constA.getConstantvalueIndex()];
						this.putField(field, val.getValue());
					}
				}
			}
		}
		// FIXME mxs: force Frame if Current kann ja nie funktionieren wenn mal einer nach dem Parent frame fragt?
		
		// Check if there is a current frame at all, since this initialization might be done with the virtual machine startup.
		if (vm.getCurrentFrame() != null || forceFrameIfCurrentNull) //  && !vm.getCurrentFrame().getMethod().getName().equals("<clinit>") TODO this can be dropped, can it?
		{
			Method method = null;
			try {
				method = representedClassFile.getClinitMethod();
			} catch (MethodResolutionError e) {
				// Do nothing, this is an expected error.
			}

			// Execute <clinit>?
			if (method != null) {
				vm.executeTheCurrentFrameForClassInitialization(method);
			}
		}

		// Some classes need special a special initialization to work correctly in this application.
		specialInitialization(vm);		
	}

	/**
	 * For wrapping reasons, some ClassFiles need a special initialization. This method
	 * checks if this applies for the represented ClassFile and takes the required
	 * actions.
	 * @param vm The currently running virtual machine.
	 * @throws ExceptionInInitializerError If special class initialization failed.
	 */
	private void specialInitialization(VirtualMachine vm) {
		try {
			// For java.lang.System, set special PrintStream for out and err.
			if (this.representedClassFile.getName().equals("java.lang.System")) {
				// Get the fields for the err and the out object.
				Field errField = this.representedClassFile.getFieldByNameAndDescriptor("err",
						"Ljava/io/PrintStream;");
				Field outField = this.representedClassFile.getFieldByNameAndDescriptor("out",
						"Ljava/io/PrintStream;");

				// Instantiate the wrapper.
				Objectref wrapperForErr = vm
						.getAnObjectref(this.representedClassFile.getClassLoader()
								.getClassAsClassFile("de.wwu.muggl.vm.execution.nativeWrapping.PrintStreamWrapper"));
				Objectref wrapperForOut = vm
						.getAnObjectref(this.representedClassFile.getClassLoader()
								.getClassAsClassFile("de.wwu.muggl.vm.execution.nativeWrapping.PrintStreamWrapper"));

				// Put the wrapper.
				this.fields.put(errField, wrapperForErr);
				this.fields.put(outField, wrapperForOut);

				/*
				 * Set the special field of the wrapper to preserve the information whether err or
				 * out was used.
				 */
				Field wrapperForField = wrapperForErr.getInitializedClass().getClassFile()
							.getFieldByNameAndDescriptor("wrapperFor", "Ljava/lang/String;");
				wrapperForErr.putField(wrapperForField, "java.lang.System.err");
				wrapperForOut.putField(wrapperForField, "java.lang.System.out");
			}
		} catch (ClassFileException e) {
			throw new ExceptionInInitializerError(
					"Initialization of the System.err/System.out-Wrapper "
					+ " failed with a ClassFileException with message: " + e.getMessage() + ".");
		}
	}

	/**
	 * Getter for the ClassFile that is represented.
	 * @return The ClassFile that is represented.
	 */
	public ClassFile getClassFile() {
		return this.representedClassFile;
	}

	/**
	 * Return a String representation of the represented ClassFile.
	 * @return A String representation of the represented ClassFile.
	 */
	@Override
	public String toString() {
		return "Static reference of " + this.representedClassFile.getName();
	}

	/**
	 * Get a new instance of this InitializedClass. It will contain a reference to
	 * the InitializedClass generated by the ClassFile, which is responsible for
	 * the management of static fields.
	 * @return A new instance of this Objectref.
	 */
	public Objectref getANewInstance() {
		Objectref objectRef = new Objectref(this, false);
		if(Options.getInst().javaEEMode) {
			injectDependencyFields(objectRef);
		}
		return objectRef;
	}

	/**
	 * Inject dependencies for special annotated fields.
	 * @param objectRef the object reference to inject dependencies for.
	 */
	protected void injectDependencyFields(Objectref objectRef) {
		Constant[] constantPool = this.representedClassFile.getConstantPool();
		for(Field field : this.representedClassFile.getFields()) {
			for (Attribute attribute : field.getAttributes()) {
				if (attribute.getStructureName().equals("attribute_runtime_visible_annotation")) {
					AttributeRuntimeVisibleAnnotations attributeAnnotation = (AttributeRuntimeVisibleAnnotations) attribute;
					for(Annotation annotation : attributeAnnotation.getAnnotations()) {
						checkAnnotationForDependency(objectRef, field, annotation, constantPool);
					}
				}
			}
		}
	}
	
	/**
	 * Check if any dependency injection is supported for the given annotation on the given field of the given object reference.
	 * @param objectRef the object reference to inject dependencies for.
	 * @param field the field of the object reference to check for dependency injection
	 * @param annotation the annotation at the field to check for supported dependency injection
	 * @param constantPool the constant pool of the class of the object reference
	 */
	private void checkAnnotationForDependency(Objectref objectRef, Field field, Annotation annotation, Constant[] constantPool) {
		String annotationName = constantPool[annotation.getTypeIndex()].getStringValue();
		if(annotationName.equals(JavaEEConstants.ANNOTATION_PERSISTENCE_CONTEXT)) {
			objectRef.fields.put(field, MugglEntityManager.getInstance());
		}
	}
	
	/**
	 * Get a new instance of this InitializedClass that will work as a wrapper
	 * for a primitive type. Only the following ClassFiles might be initialized
	 * as a primitive wrapper:
	 * java.lang.Boolean
	 * java.lang.Byte
	 * java.lang.Character
	 * java.lang.Double
	 * java.lang.Float
	 * java.lang.Integer
	 * java.lang.Long
	 * java.lang.Short
	 *
	 * @return A new instance of this Objectref acting as a wrapper for primitive types.
	 * @throws PrimitiveWrappingImpossibleException If the represented ClassFile cannot be used as a primitive wrapper.
	 */
	public Objectref getANewPrimitiveWrapper() throws PrimitiveWrappingImpossibleException {
		String name = this.representedClassFile.getName();
		if (!(name.equals("java.lang.Boolean")) && !(name.equals("java.lang.Byte"))
				&& !(name.equals("java.lang.Character")) && !(name.equals("java.lang.Double"))
				&& !(name.equals("java.lang.Float")) && !(name.equals("java.lang.Integer"))
				&& !(name.equals("java.lang.Long")) && !(name.equals("java.lang.Short")))
			throw new PrimitiveWrappingImpossibleException("This ClassFile cannot be used to wrap a primitive type.");
		return new Objectref(this, true);
	}

	/**
	 * Getter for the static fields.
	 *
	 * @return The static fields Hashtable.
	 */
	public HashMap<Field, Object> getStaticFields() {
		return this.fields;
	}
}
