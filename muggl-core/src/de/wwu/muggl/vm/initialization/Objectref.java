package de.wwu.muggl.vm.initialization;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Set;

import de.wwu.muggl.solvers.expressions.Expression;
import de.wwu.muggl.solvers.expressions.IntConstant;
import de.wwu.muggl.solvers.expressions.Variable;
import de.wwu.muggl.vm.Universe;
import de.wwu.muggl.vm.VmSymbols;
import de.wwu.muggl.vm.VmSymbols.BasicType;
import de.wwu.muggl.vm.classfile.ClassFile;
import de.wwu.muggl.vm.classfile.structures.Field;
import de.wwu.muggl.vm.execution.NativeWrapper;
import de.wwu.muggl.vm.threading.Monitor;

/**
 * This class represents a concrete instance of a ClassFile. It especially offers access
 * to the instance fields, as well as means of wrapping java objects to an objectref and
 * of extracting the fields of object references to insert them into java objects.
 *
 * @author Tim Majchrzak
 * @version 1.0.0, 2010-03-10
 */
public class Objectref extends FieldContainer implements ReferenceValue {
	// Fields
	protected InitializedClass staticReference;
	private boolean primitiveWrapper;
	private Monitor monitor;
	private long instantiationNumber;
	// if we're instance of java/lang/class, we're the class object for staticReference
	private ClassFile mirrorMuggl; // link to the "original object" of which I'm the class representation. Might only be null if this represents a class for a primitive object
	private boolean mirroredMugglIsArray = false; // if the "original" is being used in an array
	private Arrayref mirroredMugglArray = null; 
	
	// could be the equivalence of jvm's internal address field purpose
	private HashMap<String, Object> sysfields= new HashMap<>();
	
	public static final String SYSFIELDNAME_ARRAYCLASS="isClassForArray";
	public static final String SYSFIELDNAME_ARRAYCLASS_COMPONENTTYPE = "ObjectrefClassComponentType";
	// FIXME TODO mxs? add virtual method table for better resolution?
	
	/**
	 * to aid debugging, because this objectref has no reference to VM which would be needed,
	 * to have a classloader, to extract the "name" field. So store some debug info (primitive value, class name) here
	 */
	private String debugHelperString;
	/**
	 * Private constructor to get concrete instances of an initialized class. These instances
	 * have a reference to the InitializedClass, which keeps control of the static
	 * fields. The concrete instance itself keeps control of instance fields.
	 * @param staticReference The InitializedClass (which has been generated by the ClassFile).
	 * @param primitiveWrapper Toggles the usage of the Objectref as a wrapper for primitive types.
	 */
	public Objectref(InitializedClass staticReference, boolean primitiveWrapper) {
		this.staticReference = staticReference;
		this.primitiveWrapper = primitiveWrapper;
		this.instantiationNumber = staticReference.getClassFile().getClassLoader()
				.getNextInstantiationNumber();
	}

	/**
	 * Getter for the monitor associated with this objectref.
	 * @return The monitor associated with this objectref (might be null if there is no such one).
	 */
	public Monitor getMonitor() {
		return this.monitor;
	}

	/**
	 * Sets the monitor to be associated with this objectref. This will only work
	 * if there currently is no monitor associated.
	 * @param monitor The monitor that will be associated with this objectref.
	 */
	public void setMonitor(Monitor monitor) {
		if (this.monitor == null) this.monitor = monitor;
	}

	/**
	 * Return a String representation of the represented Class.
	 * @return A String representation of the represented Class.
	 */
	@Override
	public String toString() {
		String dbghint = (debugHelperString != null) ? " dbghint: " + this.debugHelperString : "";
		if(this.staticReference.getClassFile().getName().equals("java.lang.String") && (dbghint.length()==0)) {
			if (!this.fields.isEmpty()) {
				dbghint = " val: " + NativeWrapper.stringObjectrefToString(this);;
			}
		} else if(this.staticReference.getClassFile().getName().equals("java.lang.Boolean") && (dbghint.length()==0)) {
            if (!this.fields.isEmpty()) {
                Field valueField = this.getInitializedClass().getClassFile().getFieldByNameAndDescriptor("value", "Z");
                Object val_real = this.getField(valueField);
                if (val_real instanceof Integer) {
                    dbghint = " val: " + ((int)val_real != 0);
                } else if (val_real instanceof Variable) {
                    dbghint = " var: " + ((Variable) val_real).getName();
                } else{
                    dbghint = " val: " + (boolean)val_real;
                }
            }
        } else if(this.staticReference.getClassFile().getName().equals("java.lang.Integer") && (dbghint.length()==0)) {
            if (!this.fields.isEmpty()) {
                Field valueField = this.getInitializedClass().getClassFile().getFieldByNameAndDescriptor("value", "I");
                Object val_real = this.getField(valueField);
                if (val_real instanceof Variable) {
                    dbghint = " var: " + ((Variable) val_real).getName();
                } else if (val_real instanceof IntConstant) {
                    dbghint = " val: " + ((IntConstant) val_real).getIntValue();
                } else if (val_real instanceof Expression) {
                    dbghint = " val: " + ((Expression) val_real).toString(false);
                } else {
                    dbghint = " val: " + ((int) val_real);
                }
            }
        }
		return "Objectref " + this.staticReference.getClassFile().getName() + " (id: " + this.instantiationNumber
				+ dbghint + ")";
	}

	/**
	 * Return false, since this is not a reference to an array.
	 * @return false, since this is not a reference to an array.
	 */
	public boolean isArray() {
		return false;
	}

	/**
	 * Get the name of this reference value.
	 *
	 * @return The name of this reference value.
	 */
	public String getName() {
		return this.staticReference.getClassFile().getName();
	}
	
	public String getSignature() {
		if (this.primitiveWrapper) {
			return VmSymbols.basicType2Signature(
					VmSymbols.javaClassName2BasicType(staticReference.getClassFile().getName().replace('.', '/')));
		} else
			return "L" + this.staticReference.getClassFile().getName() + ";";
	}

	/**
	 * Getter for the corresponding InitializedClass.
	 * @return The corresponding InitializedClass.
	 */
	public InitializedClass getInitializedClass() {
		return this.staticReference;
	}

	/**
	 * Returns true, if the ReferenceValue is wrapping a primitive type.
	 * @return true, if the ReferenceValue is wrapping a primitive type, false otherwise.
	 */
	public boolean isPrimitive() {
		return this.primitiveWrapper;
	}

	/**
	 * Getter for the instantiation number. Instantiation numbers can be used
	 * to determine which of two ReferenceValues has been generated earlier.
	 * @return The instantiation number.
	 */
	public long getInstantiationNumber() {
		return this.instantiationNumber;
	}

	/**
	 * Check if the supplied object is equal to this object reference. 
	 * 
	 * @param obj The object to check equality with.
	 * @return true, if the supplied object is equal to this object reference, false otherwise.
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Objectref) {
			return equals((Objectref) obj);
		}
		return false;
	}
	
	/**
	 * Check if the supplied object reference is equal to this object reference. Equality is given if
	 * <ul>
	 * <li>the represented class of the static reference is equal,</li>
	 * <li>there is the same number of static fields, each field exists in both references and it has the same value and</li>
	 * <li>there is the same number of instance fields, each field exists in both references and it has the same value.</li>
	 * </ul>
	 *
	 * @param objectref The object reference to check equality with.
	 * @return true, if the supplied object reference is equal to this object reference, false otherwise.
	 */
	public boolean equals(Objectref objectref) {
		// First compare the ClassFile references.
		if (this.staticReference.getClassFile() != objectref.staticReference.getClassFile()) return false;

		// Then compare all static fields. First by size, the element by element.
		if (this.staticReference.fields.size() != objectref.staticReference.fields.size())
			return false;
		for (Entry<Field, Object> field : this.staticReference.fields.entrySet()) {
			if (!objectref.staticReference.fields.containsKey(field.getKey()))
				return false;
			if (!(ObjectComparator.compareObjects(field.getValue(),
					objectref.staticReference.fields.get(field.getKey()))))
				return false;
		}

		// Finally compare all instance fields.
		if (this.fields.size() != objectref.fields.size())
			return false;
		for (Entry<Field, Object> field : this.fields.entrySet()) {
			if (!objectref.fields.containsKey(field.getKey()))
				return false;
			if (!(ObjectComparator.compareObjects(field.getValue(), objectref.fields.get(field.getKey()))))
				return false;
		}
		
		// Reaching this point means that the values are equal.
		return true;
	}

	/**
	 * Return the unique instantiation number of this object reference.
	 *
	 * @return The instantiation number of this object reference.
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode() {
		return (int) this.instantiationNumber;
	}

	/**
	 * Reset the cached java object and assign a value to a Field.
	 * @param field The Field to get a new value assigned.
	 * @param value The new value.
	 * @throws FieldAccessError If the Field does not belong to the Class represented by this InitializedClass.
	 */
	@Override
	public void putField(Field field, Object value) {
		super.putField(field, value);
	}

	/**
	 * Getter for the fields.
	 *
	 * @return The fields Hashtable.
	 */
	public HashMap<Field, Object> getFields() {
		return this.fields;
	}

	public String getDebugHelperString() {
		return debugHelperString;
	}

	public void setDebugHelperString(String debugHelperString) {
		this.debugHelperString = debugHelperString;
	}

	public ClassFile getMirrorMuggl() {
		return mirrorMuggl;
	}

	public void setMirrorMuggl(ClassFile mirrorMuggl) {
		this.mirrorMuggl = mirrorMuggl;
	}

	@SuppressWarnings("unchecked")
	public Objectref clone() throws CloneNotSupportedException {
		Objectref clone = (Objectref) super.clone();
        clone.instantiationNumber = staticReference.getClassFile().getClassLoader()
                .getNextInstantiationNumber();
		clone.sysfields = (HashMap<String, Object>) this.sysfields.clone();
		clone.fields = (HashMap<Field, Object>) this.fields.clone();// new HashMap<>();
		return clone;
	}
	
	
	/**
	 * Treat Objectref as representation of a java.lang.Class instance and make its methods accessible
	 * @return
	 */
	public ObjectrefAsClass asClass() {
		// make sure we can be treated as representation of 
		// java.lang.Class
		if (!this.getInitializedClass().getClassFile().getName().equals("java.lang.Class")) {
			new Exception("must be representing java.lang.Class!");
		}
		return new ObjectrefAsClass(this);
	}

	public boolean isMirroredMugglIsArray() {
		return mirroredMugglIsArray;
	}

	public void setMirroredMugglIsArray(boolean mirroredMugglIsArray) {
		this.mirroredMugglIsArray = mirroredMugglIsArray;
	}

	public Arrayref getMirroredMugglArray() {
		return mirroredMugglArray;
	}

	public void setMirroredMugglArray(Arrayref mirroredMugglArray) {
		this.mirroredMugglArray = mirroredMugglArray;
	}

	/**
	 * Takes into account if this is a primitive and redirects accordingly
	 * @return
	 */
	public Objectref getMirrorJava() {
		if (this.isPrimitive()){			
			BasicType type = VmSymbols.javaClassName2BasicType(this.getInitializedClass().getClassFile().getName().replace('.', '/'));
			return Universe.java_mirror(type);	
		}			
		else
			return this.getInitializedClass().getClassFile().getMirrorJava();
	}
	
	public HashMap<String, Object> getSysfields() {
		return this.sysfields;
	}

    /**
     * This method is used in context with free objects in order to find out whether it is already a specific object.
     * For an Objectref, it is always true, i.e. it is not a Free Object. FreeObjectref overrides this and may provide a more
     * nuanced implementation.
     * @return true if the represented Object is a specific one.
     */
	public boolean isOfASpecificType() {
	    return true;
    }

    @Override
    public Set<String> getPossibleTypes() {
        HashSet<String> types = new HashSet<>();
        types.add(getInitializedClass().getClassFile().getName());
        return types;
    }
}
