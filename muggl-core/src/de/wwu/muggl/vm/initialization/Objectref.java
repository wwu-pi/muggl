package de.wwu.muggl.vm.initialization;

import java.util.HashMap;
import java.util.Map.Entry;

import de.wwu.muggl.configuration.Options;
import de.wwu.muggl.solvers.expressions.IntConstant;
import de.wwu.muggl.vm.Universe;
import de.wwu.muggl.vm.VmSymbols;
import de.wwu.muggl.vm.VmSymbols.BasicType;
import de.wwu.muggl.vm.classfile.ClassFile;
import de.wwu.muggl.vm.classfile.structures.Field;
import de.wwu.muggl.vm.threading.Monitor;

/**
 * This class represents a concrete instance of a ClassFile. It especially offers access
 * to the instance fields, as well as means of wrapping java objects to an objectref and
 * of extracting the fields of object references to insert them into java objects.
 *
 * @author Tim Majchrzak
 * @version 1.0.0, 2010-03-10
 */
public class Objectref extends FieldContainer implements ReferenceValue {
	// Fields
	private InitializedClass staticReference;
	private boolean primitiveWrapper;
	private Monitor monitor;
	private long instantiationNumber;
	// if we're instance of java/lang/class, we're the class object for staticReference
	private ClassFile mirrorMuggl; // link to the "original object" of which I'm the class representation. Might only be null if this represents a class for a primitive object
	private boolean mirroredMugglIsArray = false; // if the "original" is being used in an array
	private Arrayref mirroredMugglArray = null; 
	
	// could be the equivalence of jvm's internal address field purpose
	private HashMap<String, Object> sysfields= new HashMap<>();
	
	public static final String SYSFIELDNAME_ARRAYCLASS="isClassForArray";
	public static final String SYSFIELDNAME_ARRAYCLASS_COMPONENTTYPE = "ObjectrefClassComponentType";
	// FIXME TODO mxs? add virtual method table for better resolution?
	
	/**
	 * to aid debugging, because this objectref has no reference to VM which would be needed,
	 * to have a classloader, to extract the "name" field. So store some debug info (primitive value, class name) here
	 */
	private String debugHelperString;
	/**
	 * Private constructor to get concrete instances of an initialized class. These instances
	 * have a reference to the InitializedClass, which keeps control of the static
	 * fields. The concrete instance itself keeps control of instance fields.
	 * @param staticReference The InitializedClass (which has been generated by the ClassFile).
	 * @param primitiveWrapper Toggles the usage of the Objectref as a wrapper for primitive types.
	 */
	public Objectref(InitializedClass staticReference, boolean primitiveWrapper) {
		this.staticReference = staticReference;
		this.primitiveWrapper = primitiveWrapper;
		this.instantiationNumber = staticReference.getClassFile().getClassLoader()
				.getNextInstantiationNumber();
	}

	/**
	 * Getter for the monitor associated with this objectref.
	 * @return The monitor associated with this objectref (might be null if there is no such one).
	 */
	public Monitor getMonitor() {
		return this.monitor;
	}

	/**
	 * Sets the monitor to be associated with this objectref. This will only work
	 * if there currently is no monitor associated.
	 * @param monitor The monitor that will be associated with this objectref.
	 */
	public void setMonitor(Monitor monitor) {
		if (this.monitor == null) this.monitor = monitor;
	}

	/**
	 * Return a String representation of the represented Class.
	 * @return A String representation of the represented Class.
	 */
	@Override
	public String toString() {
		String dbghint = (debugHelperString != null) ? " dbghint: " + this.debugHelperString : "";
		if(this.staticReference.getClassFile().getName().equals("java.lang.String") && (dbghint.length()==0)) {
			if (!this.fields.isEmpty()) {
				// Get the array of characters.
				Arrayref arrayref = (Arrayref) this.getField(this.getInitializedClass().getClassFile().getFieldByName("value"));

				// Convert it.
				boolean symbolicalMode = Options.getInst().symbolicMode;
				char[] characters = new char[arrayref.length];
				for (int a = 0; a < arrayref.length; a++) {
					if (symbolicalMode) {
						characters[a] = (char) ((IntConstant) arrayref.getElement(a)).getIntValue();
					} else {
						characters[a] = (Character) arrayref.getElement(a);
					}
				}
				dbghint = " val:" + String.valueOf(characters);			
			}
		}
		return "Objectref " + this.staticReference.getClassFile().getName() + " (id: " + this.instantiationNumber
				+ dbghint + ")";
	}

	/**
	 * Return false, since this is not a reference to an array.
	 * @return false, since this is not a reference to an array.
	 */
	public boolean isArray() {
		return false;
	}

	/**
	 * Get the name of this reference value.
	 *
	 * @return The name of this reference value.
	 */
	public String getName() {
		return this.staticReference.getClassFile().getName();
	}
	
	public String getSignature() {
		if (this.primitiveWrapper) {
			return VmSymbols.basicType2Signature(
					VmSymbols.javaClassName2BasicType(staticReference.getClassFile().getName().replace('.', '/')));
		} else
			return "L" + this.staticReference.getClassFile().getName() + ";";
	}

	/**
	 * Getter for the corresponding InitializedClass.
	 * @return The corresponding InitializedClass.
	 */
	public InitializedClass getInitializedClass() {
		return this.staticReference;
	}

	/**
	 * Returns true, if the ReferenceValue is wrapping a primitive type.
	 * @return true, if the ReferenceValue is wrapping a primitive type, false otherwise.
	 */
	public boolean isPrimitive() {
		return this.primitiveWrapper;
	}

	/**
	 * Getter for the instantiation number. Instantiation numbers can be used
	 * to determine which of two ReferenceValues has been generated earlier.
	 * @return The instantiation number.
	 */
	public long getInstantiationNumber() {
		return this.instantiationNumber;
	}

	/**
	 * Check if the supplied object is equal to this object reference. 
	 * 
	 * @param obj The object to check equality with.
	 * @return true, if the supplied object is equal to this object reference, false otherwise.
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Objectref) {
			return equals((Objectref) obj);
		}
		return false;
	}
	
	/**
	 * Check if the supplied object reference is equal to this object reference. Equality is given if
	 * <ul>
	 * <li>the represented class of the static reference is equal,</li>
	 * <li>there is the same number of static fields, each field exists in both references and it has the same value and</li>
	 * <li>there is the same number of instance fields, each field exists in both references and it has the same value.</li>
	 * </ul>
	 *
	 * @param objectref The object reference to check equality with.
	 * @return true, if the supplied object reference is equal to this object reference, false otherwise.
	 */
	public boolean equals(Objectref objectref) {
		// First compare the ClassFile references.
		if (this.staticReference.getClassFile() != objectref.staticReference.getClassFile()) return false;

		// Then compare all static fields. First by size, the element by element.
		if (this.staticReference.fields.size() != objectref.staticReference.fields.size())
			return false;
		for (Entry<Field, Object> field : this.staticReference.fields.entrySet()) {
			if (!objectref.staticReference.fields.containsKey(field.getKey()))
				return false;
			if (!(ObjectComparator.compareObjects(field.getValue(),
					objectref.staticReference.fields.get(field.getKey()))))
				return false;
		}

		// Finally compare all instance fields.
		if (this.fields.size() != objectref.fields.size())
			return false;
		for (Entry<Field, Object> field : this.fields.entrySet()) {
			if (!objectref.fields.containsKey(field.getKey()))
				return false;
			if (!(ObjectComparator.compareObjects(field.getValue(), objectref.fields.get(field.getKey()))))
				return false;
		}
		
		// Reaching this point means that the values are equal.
		return true;
	}

	/**
	 * Return the unique instantiation number of this object reference.
	 *
	 * @return The instantiation number of this object reference.
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode() {
		return (int) this.instantiationNumber;
	}

	/**
	 * Reset the cached java object and assign a value to a Field.
	 * @param field The Field to get a new value assigned.
	 * @param value The new value.
	 * @throws FieldAccessError If the Field does not belong to the Class represented by this InitializedClass.
	 */
	@Override
	public void putField(Field field, Object value) {
		super.putField(field, value);
	}

	/**
	 * Getter for the fields.
	 *
	 * @return The fields Hashtable.
	 */
	public HashMap<Field, Object> getFields() {
		return this.fields;
	}

	public String getDebugHelperString() {
		return debugHelperString;
	}

	public void setDebugHelperString(String debugHelperString) {
		this.debugHelperString = debugHelperString;
	}

	public ClassFile getMirrorMuggl() {
		return mirrorMuggl;
	}

	public void setMirrorMuggl(ClassFile mirrorMuggl) {
		this.mirrorMuggl = mirrorMuggl;
	}

	@SuppressWarnings("unchecked")
	public Objectref clone() throws CloneNotSupportedException {
		Objectref clone = (Objectref) super.clone();
		clone.sysfields = (HashMap<String, Object>) this.sysfields.clone();
		return clone;
	}
	
	
	/**
	 * Treat Objectref as representation of a java.lang.Class instance and make its methods accessible
	 * @return
	 */
	public ObjectrefAsClass asClass() {
		// make sure we can be treated as representation of 
		// java.lang.Class
		if (!this.getInitializedClass().getClassFile().getName().equals("java.lang.Class")) {
			new Exception("must be representing java.lang.Class!");
		}
		return new ObjectrefAsClass(this);
	}

	public boolean isMirroredMugglIsArray() {
		return mirroredMugglIsArray;
	}

	public void setMirroredMugglIsArray(boolean mirroredMugglIsArray) {
		this.mirroredMugglIsArray = mirroredMugglIsArray;
	}

	public Arrayref getMirroredMugglArray() {
		return mirroredMugglArray;
	}

	public void setMirroredMugglArray(Arrayref mirroredMugglArray) {
		this.mirroredMugglArray = mirroredMugglArray;
	}

	/**
	 * Takes into account if this is a primitive and redirects accordingly
	 * @return
	 */
	public Objectref getMirrorJava() {
		if (this.isPrimitive()){			
			BasicType type = VmSymbols.javaClassName2BasicType(this.getInitializedClass().getClassFile().getName().replace('.', '/'));
			return Universe.java_mirror(type);	
		}			
		else
			return this.getInitializedClass().getClassFile().getMirrorJava();
	}
	
	public HashMap<String, Object> getSysfields() {
		return this.sysfields;
	}
}
