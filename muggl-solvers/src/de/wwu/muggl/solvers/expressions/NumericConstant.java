package de.wwu.muggl.solvers.expressions;

import java.util.Set;

import de.wwu.muggl.solvers.Solution;
import de.wwu.muggl.solvers.solver.constraints.Assignment;
import de.wwu.muggl.solvers.solver.constraints.Polynomial;
import de.wwu.muggl.solvers.solver.tools.Substitution;
import de.wwu.muggl.solvers.solver.tools.SubstitutionTable;

/**
 * Superclass for all numeric constants generated by the virtual machine.
 * @author Christoph Lembeck
 */
public abstract class NumericConstant extends Term implements Constant{

    /**
     * Get or create a new instance of NumericConstant with the given value and type.
     * @param value the value which the constant is supposed to has.
     * @param type the desired type according to {@link Expression}.
     * @return the desired numeric constant.
     */
    public static NumericConstant getInstance(int value, byte type){
	switch (type){
	case Expression.DOUBLE:
	    return DoubleConstant.getInstance(value);
	case Expression.FLOAT:
	    return FloatConstant.getInstance(value);
	case Expression.LONG:
	    return LongConstant.getInstance(value);
	default:
	    return IntConstant.getInstance(value);
	}
    }


    /**
     * Get or create a new instance of NumericConstant from a boxed type.
     */
    public static NumericConstant getInstance(Object value) {
        if (value instanceof Double) {
            return DoubleConstant.getInstance(((Double) value).doubleValue());
        } else if (value instanceof Float) {
            return FloatConstant.getInstance(((Float) value).floatValue());
        } else if (value instanceof Long) {
            return LongConstant.getInstance(((Long) value).longValue());
        } else {
            return IntConstant.getInstance(((Integer) value).intValue());
        }
    }

    /**
     * Returns the object representing the constant one of the specified type.
     * @param type the type the constant one should have.
     * @return the constant one of the specified type
     */
    public static NumericConstant getOne(byte type){
	switch(type){
	case Expression.DOUBLE: return DoubleConstant.ONE;
	case Expression.FLOAT: return FloatConstant.ONE;
	case Expression.LONG: return LongConstant.ONE;
	default: return IntConstant.ONE;
	}
    }

    /**
     * Returns the object representating the constant zero of the specified type.
     * @param type the type the constant one should have.
     * @return the constant zero of the specified type
     */
    public static NumericConstant getZero(byte type){
	switch(type){
	case Expression.DOUBLE: return DoubleConstant.ZERO;
	case Expression.FLOAT: return FloatConstant.ZERO;
	case Expression.LONG: return LongConstant.ZERO;
	default: return IntConstant.ZERO;
	}
    }

    /**
     * Used to calculate the absolute value of this Constant. 
     * @return the absolute value of this constant.
     */
    public abstract NumericConstant abs();

    /**
     * Adds the passed constant to this constant.
     * @param addend the constant that should be added.
     * @return the sum of the two constants.
     */
    public abstract NumericConstant add(NumericConstant addend);

    /**
     * Returns the bitwise conjunction (and) of the passed constant and this one.
     * @param constant the other argument for the conjuntion.
     * @return the bitwise conjunction (and) of the passed constant and this one.
     */
    public abstract NumericConstant and(NumericConstant constant);

    /**
     * Transforms this constant into a constant having the passed type.
     * @param type the type into which the constant should be casted using the
     * type representation specified in the interface Expression.
     * @return a constant of the passed type representing the number that will
     * be generated by a real java typecast.
     * @see de.wwu.muggl.solvers.expressions.Expression
     */
    public abstract NumericConstant castTo(byte type);

    /**
     * Does nothing because the types of constants are immutable and hence always
     * valid.
     */
    @Override
    public void checkTypes(){/* nothing to do here */}

    @Override
    public Term clearMultiFractions(Set<Term> denominators){
	return this;
    }

    /**
     * Always returns <i>false</i> because constants do not contain any other
     * expressions.
     * @param t the term that should be searched for.
     * @return <i>false</i>.
     */
    @Override
    protected boolean containsAsDenominator(Term t){
	return false;
    }

    /**
     * Divides this constant by the passed one and returns the result.
     * @param divisor the constant that should be added.
     * @return the quotient sum of this constant and the argument.
     */
    public abstract NumericConstant divide(NumericConstant divisor);

    @Override
    protected Substitution findSubstitution(SubstitutionTable subTable) {
	Substitution result = subTable.lookupSubstitution(this);
	return result;
    }

    /**
     * Returns <i>null</i>, because constants do not contain any denominators.
     * @return <i>null</i>.
     */
    @Override
    protected Set<Term> getDenominators(){
	return null;
    }

    /**
     * Returns the value of this constant as a double.
     * @return the numeric value represented by this constant after conversion to
     * type double.
     */
    public abstract double getDoubleValue();

    /**
     * Returns null as constants do not contain any other expressions as subnodes.
     * @return <i>null</i>.
     */
    @Override
    protected Modulo getFirstModulo() {
	return null;
    }

    @Override
    protected Quotient getFirstNonintegerQuotient(){
	return null;
    }

    /**
     * Returns null as constants do not contain any other expressions as subnodes.
     * @return <i>null</i>.
     */
    @Override
    protected Quotient getFirstQuotient() {
	return null;
    }

    /**
     * Returns null as constants do not contain any other expressions as subnodes.
     * @param onlyNarrowing <i>unused</i>.
     * @return <i>null</i>.
     */
    @Override
    protected TypeCast getFirstTypeCast(boolean onlyNarrowing) {
	return null;
    }

    /**
     * Returns the value of this constant as a float.
     * @return the numeric value represented by this constant after conversion to
     * type float.
     */
    public abstract float getFloatValue();

    /**
     * @return null as this is a constant
     */
    @Override
    protected Modulo getInmostModulo() {
	return null;
    }

    /**
     * @return null as this is a constant
     */
    @Override
    protected Quotient getInmostQuotient() {
	return null;
    }

    /**
     * Returns the value of this constant as a int.
     * @return the numeric value represented by this constant after conversion to
     * type int.
     */
    public abstract int getIntValue();

    /**
     * Returns the value of this constant as a long.
     * @return the numeric value represented by this constant after conversion to
     * type long.
     */
    public abstract long getLongValue();

    @Override
    public Term insertAssignment(Assignment assignment){
	return this;
    }

    /**
     * Returns this constant.
     * @param solution unused.
     * @param produceNumericSolution unused.
     * @return this object.
     */
    @Override
    public Term insert(Solution solution, boolean produceNumericSolution){
	return this;
    }

    /**
     * Returns true because this is definitely a constant.
     * @return <code>true</code>.
     */
    public boolean isConstant(){
	return true;
    }

    /**
     * Checks whether the value represented by this constant is numeric equal to
     * the value represented by the other constant.
     * @param arg the other constant, whose value should be compared to this one.
     * @return <code>true</code> if the value represented by this constant is equal
     * to the value of the other constant.
     */
    public abstract boolean isEqualTo(NumericConstant arg);

    /**
     * Checks whether the constant is greater than or equal to the passed
     * argument.
     * @param arg the constant this constant should be compared to.
     * @return <i>true</i> if this constant is greater than or equal to the
     * passed argument, <i>false</i> otherwise.
     */
    public abstract boolean isGreaterOrEqual(NumericConstant arg);

    /**
     * Checks whether the constant is greater than the passed argument.
     * @param arg the constant this constant should be compared to.
     * @return <i>true</i> if this constant is greater than the passed argument,
     * <i>false</i> otherwise.
     */
    public abstract boolean isGreaterThan(NumericConstant arg);

    /**
     * Checks whehter the constant is of an integer type.
     * @return <code>true</code> if the constant has an integer type,
     * <code>false</code> otherwise.
     */
    public abstract boolean isInteger();

    /**
     * Checks whether the constant is lesser than or equal to the passed
     * argument.
     * @param arg the constant this constant should be compared to.
     * @return <i>true</i> if this constant is lesser than or equal to the
     * passed argument, <i>false</i> otherwise.
     */
    public abstract boolean isLesserOrEqual(NumericConstant arg);

    /**
     * Checks whether the constant is lesser than the passed argument.
     * @param arg the constant this constant should be compared to.
     * @return <i>true</i> if this constant is lesser than the passed argument,
     * <i>false</i> otherwise.
     */
    public abstract boolean isLesserThan(NumericConstant arg);

    /**
     * Checks if this constant is equal to the constant value minus one.
     * @return <i>true</i> if this constant is equal to minus one, <i>false</i>
     * otherwise.
     */
    public abstract boolean isMinusOne();

    /**
     * Checks if this constant is lesser than zero or not.
     * @return <i>true</i> if this constant is lesser than the constant zero,
     * <i>false</i> otherwise.
     */
    public abstract boolean isNegative();

    /**
     * Checks if this constant is lesser than or equal to zero or not.
     * @return <i>true</i> if this constant is lesser than or equal to the
     * constant zero, <i>false</i> otherwise.
     */
    public abstract boolean isNegativeOrZero();

    /**
     * Checks whether the value represented by this constant is numeric not equal to
     * the value represented by the other constant.
     * @param arg the other constant, whose value should be compared to this one.
     * @return <code>true</code> if the value rpresented by this constant is not equal
     * to the value of the other constant, <code>false</code> if the values are equal.
     */
    public abstract boolean isNotEqualTo(NumericConstant arg);

    /**
     * Checks if this constant is equal to the constant value one.
     * @return <i>true</i> if this constant is equal to one, <i>false</i>
     * otherwise.
     */
    public abstract boolean isOne();

    /**
     * Checks if this constant is greater than zero or not.
     * @return <i>true</i> if this constant is greater than the constant zero,
     * <i>false</i> otherwise.
     */
    public abstract boolean isPositive();

    /**
     * Checks if this constant is greater than or equal to zero or not.
     * @return <i>true</i> if this constant is greater than or equal to the
     * constant zero, <i>false</i> otherwise.
     */
    public abstract boolean isPositiveOrZero();

    /**
     * Checks if this constant is equal to the constant value zero.
     * @return <i>true</i> if this constant is equal to zero, <i>false</i>
     * if it is any other value.
     */
    public abstract boolean isZero();

    /**
     * Returns the remainder of the division of this value by the passed one.
     * @param divisor the divisor of the remainder operation.
     * @return the remainder of the division of this value by the passed one.
     */
    public abstract NumericConstant modulo(NumericConstant divisor);

    /**
     * Multiplies the passed constant with this constant.
     * @param factor the constant this constant should be multiplied with.
     * @return the product of the two constants.
     */
    public abstract NumericConstant multiply(NumericConstant factor);

    @Override
    protected Term multiply(Term factor){
	return Product.newInstance(factor, this);
    }

    /**
     * Returns a constant having the same magnitude as this constant but a
     * different sign.
     * @return the constant having the same magnitude as this constant but a
     * different sign.
     */
    public abstract NumericConstant negate();

    /**
     * TODOME doc!
     * @return
     */
    public abstract NumericConstant next();

    /**
     * Returns the bitwise inclusive or of the passed constant and this one.
     * @param constant the other argument for the inclusive or.
     * @return the bitwise inclusive or of the passed constant and this one.
     */
    public abstract NumericConstant or(NumericConstant constant);

    /**
     * Returns the <i>exp</i>th power of this number.
     * @param exp the exponent this number should be potentized with.
     * @return the <i>exp</i>th power of this number.
     */
    public NumericConstant pow(int exp){
	if (exp == 0)
	    return getOne(getType());
	if (exp == 1)
	    return this;
	if (exp % 2 == 1)
	    return this.multiply(this.pow(exp - 1));
	else{
	    NumericConstant tmp = this.pow(exp / 2);
	    return tmp.multiply(tmp);
	}
    }

    public abstract NumericConstant pred();

    public abstract NumericConstant arithmeticShiftRight(int range);

    public abstract NumericConstant shiftLeft(int range);

    /**
     * Checks whether this constant is equal to the first passed argument and
     * returns in this case the second passed argument. If the constant is not
     * equal to the searched term, the constant itself will be returned.
     * @param a the term that should be substituted.
     * @param b the term that should replace the first passed term.
     * @return the second passed term if the constant is equal to the searched
     * term or the constant itself if it is not equal to the searched term.
     */
    @Override
    public Term substitute(Term a, Term b) {
	if (equals(a))
	    return b;
	else
	    return this;
    }

    /**
     * Subtracts the passed constant from this constant.
     * @param subtrahend the constant that should be subtracted.
     * @return the difference of the two constants.
     */
    public abstract NumericConstant subtract(NumericConstant subtrahend);

    /**
     * Converts this constant into an easier manageable polynomial object.
     * @return the polynomial representing the constant.
     */
    @Override
    public Polynomial toPolynomial(){
	return new Polynomial(null, this);
    }

    @Override
    public String toTexString(){
	return toString();
    }

    @Override
    public String toTexString(boolean useInternalVariableNames){
	return toString();
    }

    /**
     * Returns the bitwise exclusive or of the passed constant and this one.
     * @param constant the other argument for the exclusive or.
     * @return the bitwise exclusive or of the passed constant and this one.
     */
    public abstract NumericConstant xor(NumericConstant constant);
}
